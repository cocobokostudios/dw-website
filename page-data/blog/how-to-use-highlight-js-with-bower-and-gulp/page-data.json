{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/how-to-use-highlight-js-with-bower-and-gulp/","result":{"data":{"markdownRemark":{"html":"<p>One of the challenges I faced when getting my new blog theme up and running was getting <a href=\"https://highlightjs.org\">highlight.js</a> working as I wanted it to. The library has support for a riduculous number of languages, and provides theming capabilities, so it was the clear choice when it came to syntax highlighting for the web. The challenge is that tt's not just adding simple script tag and you're done with it. They seem to expect you to know what you're doing when consuming the library. </p>\n<p>Remember: this is a <em>good thing</em>. </p>\n<p>If you're only include code snippets for HTML and JavaScript, why would you want to bring down the stylesheets for D, Erlang, and ActionScript too? Same goes for the themes too. You're likely going to pick a single theme and go with it, and not need all 77 they include. Because of the size of highlight.js, bringing it all down to the client would have a significant impact on your site's performance.</p>\n<p>Lucky for us, the folks in charge of highlight.js have given us all the tools we need to make using the library in our application nice and performant. In my case, I use <a href=\"https://bower.io\">Bower</a> as my package manager and <a href=\"http://gulpjs.com\">Gulp</a> as my build system, which worked well once I figured out what I was doing. Let me walk you though it.</p>\n<h2>Installing Highlight.js with Bower</h2>\n<p>To start, you'll need to add highlight.js to your project using Bower.</p>\n<pre><code class=\"language-bash\">bower install --save highligh.js.origin\n</code></pre>\n<p>Generally speaking, after you install a package from Bower you have a ready-to-use JavaScript library. With highlight.js, this is not the case. Rather, you are left with source code ready to be built as you need it. To do that, we are going to use Gulp.</p>\n<h2>Building Highlight.js with Gulp</h2>\n<p>The hard work has already been done by the highlight.js team, as they have already included a lovely build tool for us to use. You can read about the details <a href=\"http://highlightjs.readthedocs.io/en/latest/building-testing.html\">here in the building and testing documentation</a>. </p>\n<p>There are two parts to \"building\" highlight.js: the JavaScript and the stylesheets. We'll be creating a task for each of them.</p>\n<h3>Building highlight.js JavaScript</h3>\n<p>Let's start with the JavaScript component.</p>\n<p>If you read the <a href=\"http://highlightjs.readthedocs.io/en/latest/building-testing.html\">docs</a> earlier, you know that there is a NodeJS script in the <code>tools</code> directory that will do all the heavy lifting. All we need to do in our Gulp task is use that script.</p>\n<p>Here's my Gulp task:</p>\n<pre><code class=\"language-javascript\">gulp.task('process-highlightjs-script', function(callback) {\n    let command = 'cd bower_components/highlight.js.origin'\n                    + ' &#x26;&#x26; npm install' \n                    + ' &#x26;&#x26; node tools/build :common';\n    exec(command, (err, stdout, stderr)=> {\n        console.log(stderr);\n        console.log(stdout);\n\n        callback(err);\n    });\n\n    return;\n});\n</code></pre>\n<p>It looks a little strange for a gulp task, but all I'm doing is executing a shell command using the <a href=\"https://nodejs.org/api/child_process.html#child_process_child_process_exec_command_options_callback\"><code>exec</code></a> in NodeJS to spawn a child process. The important part is in the <code>command</code> variable. Let's walk through it.</p>\n<pre><code class=\"language-bash\">cd bower_components/highlight.js.origin\n</code></pre>\n<p>First, I'm moving into the root directory of the highligh.js.origin package we previously installed using Bower.</p>\n<pre><code class=\"language-bash\">npm install\n</code></pre>\n<p>Then, I'm installing the dependencies that are needed by the provided build tool.</p>\n<pre><code class=\"language-bash\">node tools/build :common\n</code></pre>\n<p>Finally, I'm running the build command as specified in the documentation. This part should be changed to make sure it includes the languages you want to display in your application. Details are in their <a href=\"http://highlightjs.readthedocs.io/en/latest/building-testing.html\">documentation</a>.</p>\n<p>The rest is just outputting the standard out and standard error streams to the console, and calling the Gulp callback to make sure we come back to our original process, as per the <a href=\"https://github.com/gulpjs/gulp/blob/master/docs/API.md#async-task-support\">Gulp documentation</a>. </p>\n<p>If everything is done correctly, you should have a new <code>build</code> folder in the <code>highlight.js.origin</code> folder that contains your newly build library.</p>\n<h2>Building Highlight.js Themes for SASS</h2>\n<p>I suppose this part is optional, but it shouldn't be.</p>\n<p>To make optimize your site, you should be minimizing the number of requests that the client browser needs to make to get all the required resources for your application. For styling, that involves concatenanting all of your styles and style libraries into a single file.</p>\n<p>To do this, I use <a href=\"http://sass-lang.com\">SASS</a> or, more specifically, <a href=\"https://www.npmjs.com/package/gulp-sass\">gulp-sass</a> to build all of my stylesheets and combine them into a single CSS file as described by the <a href=\"http://sass-lang.com/guide#topic-5\">SASS documentation</a>. I'm going to assume that you're doing the same, or at least something similar in your application that will be using highlight.js.</p>\n<p>Because SASS only handles combining other <code>scss</code> files, I copy the theme stylesheet into a newly named <code>scss</code> file. Here's my gulp task for that:</p>\n<pre><code class=\"language-javascript\">gulp.task('process-highlightjs-style', function() {\n    let stylesheets = [\n        './bower_components/highlight.js.origin/src/styles/atom-one-dark.css'\n    ];\n\n    return gulp.src(stylesheets)\n            .pipe(rename('highlight.js.scss'))\n            .pipe(gulp.dest('./bower_components/highlight.js.origin/scss'));\n});\n</code></pre>\n<p>Then in my main stylesheet, I include:</p>\n<pre><code class=\"language-scss\">@import '../../bower_components/highlight.js.origin/scss/highlight.js';\n</code></pre>\n<p>This will bring in the <code>highlight.js.scss</code> file when I build my styles using <code>gulp-sass</code> in my application stylesheet build task.</p>\n<p>And now highlight.js ready to Use in our application.</p>\n<figure class=\"image\">\n    ![Highlight.js in Action](http://i.imgur.com/1cUniu9.png)\n    <figcaption>Highlight.js in Action</figcaption>\n</figure>\n<h4>Caveat About Using Highlight.js with Markdown</h4>\n<p>My post assumes that for any blocks of text where you want syntax highlighting you're comfortable using the default <a href=\"https://highlightjs.org/usage/\">highlight.js usage</a> behaviour of wrapping the code with <code>&#x3C;pre>&#x3C;code></code> elements.</p>\n<p>Although I blog using Markdown, at the time of this writing I still wrap my text with these elements, unlike <a href=\"https://help.github.com/articles/creating-and-highlighting-code-blocks/\">GitHub flavoured markdown</a> that lets define the language using regular Markdown syntax.</p>\n<p>The reason for this, is that my blog engine renders the Markdown syntax with a bunch of extra HTML woven throughout the code to display it without the need for a library like highlight.js. </p>\n<p>It might not be a big deal for you or your project, but I thought it was something you should be aware of when if you're planning on using highlight.js in your application.</p>","frontmatter":{"title":"How to Use Highlight.Js with Bower and Gulp"}}},"pageContext":{"slug":"/how-to-use-highlight-js-with-bower-and-gulp/"}},"staticQueryHashes":["3159585216"]}