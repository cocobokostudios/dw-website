<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="https://www.davidwesst.com/_next/static/-9wn_hi6_-Q32OgH9YOcv/pages/_app.js" as="script"/><link rel="preload" href="https://www.davidwesst.com/_next/static/-9wn_hi6_-Q32OgH9YOcv/pages/blog/%5Bid%5D.js" as="script"/><link rel="preload" href="https://www.davidwesst.com/_next/static/runtime/webpack-c212667a5f965e81e004.js" as="script"/><link rel="preload" href="https://www.davidwesst.com/_next/static/chunks/framework.e84fa698c7ee940652bd.js" as="script"/><link rel="preload" href="https://www.davidwesst.com/_next/static/chunks/commons.7c101d7f1672b68d7c1c.js" as="script"/><link rel="preload" href="https://www.davidwesst.com/_next/static/runtime/main-98aa3916935decc0cde3.js" as="script"/></head><body><div id="__next"><h1>How to Compile Typescript into a Single File with AMD Modules with Gulp</h1><article><div>typescript-with-amd-and-gulp</div><div>Mon Sep 12 2016 03:25:01 GMT-0500 (Central Daylight Time)</div><div><p>I've been tinkering with TypeScript lately and was trying to setup my project to compile all of my modules into a single file, which would then be used in an HTML page. Maybe this is obvious to the more experienced TypeScript developer, but I had made a number of false assumptions while trying to get this to work.</p>
<p>This post will walk you through what I did to setup my build and get it working in an HTML page.</p>
<p><strong>You can follow along at home with the source code which I've put up on <a href="https://github.com/davidwesst/ts-project-template">GitHub</a></strong></p>
<h2>Modular TypeScript</h2>
<p>My project is starting out simple, with a single module and a couple of different "Apps" that will use the module. Module in TypeScript is extensively documented in the <a href="">TypeScript Handbook</a>, so if you're not familiar with this I would suggest reading up on it as it's pretty awesome once you start using it.</p>
<p>In any case, here's my code:</p>
<pre><code class="language-typescript">// ModuleOne.ts

export class ModuleOne {
    sayHello() {
        console.log("Hello from Module1!");
    }

    sayHelloTo(who: string) {
        console.log("Hello " + who.trim() + ". This is Module1");
    }
}
</code></pre>
<pre><code class="language-typescript">// ModuleTwo.ts

export class ModuleOne {
    sayHello() {
        console.log("Hello from ModuleTwo!");
    }

    sayHelloTo(who: string) {
        console.log("Hello " + who.trim() + ". This is ModuleTwo");
    }
}
</code></pre>
<pre><code class="language-typescript">// App.ts

import * as Module1 from "./modules/Module1";
import * as Module2 from "./modules/Module2";

export class App {
    start() {
        let m1 = new Module1.ModuleOne();
        let m2 = new Module2.ModuleTwo();
        
        m1.sayHelloTo("David Wesst");
        m2.sayHelloTo("David Wesst");
    }
}
</code></pre>
<p>I have a single application that is using two modules. Plain and simple. Next up, I compile my code into a single file, then reference that in my HTML, and done like dinner.</p>
<p>...or so I thought.</p>
<h2>The <code>--outFile</code> Parameter</h2>
<p> Reading through the doucmentation about TypeScript compilation, I found the <code>--outFile</code> or <code>--out</code> parameter in the <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html">documentation</a>. I immediately assumed that I was done, as I would simple choose my ES target, select the type of modules I would like, and presto. </p>
<p> That wasn't the case.</p>
<p> Being a person who likes modern JavaScript, I had originally opted to output ES6 compatible code complete with the new modules. </p>
<p> This is was my first mistake. </p>
<p> I found was that when I compiled, I would get a single output file but it would be completely blank. No error, but just an empty file. This is expected behaviour, as the <code>--outFile</code> option only supports <em>commonjs</em> and <em>amd</em>. That meant no ES6 or even ES2015 modules for my project, which is probably for the best considering how few web browsers in the wild actually support ES6 modules as of this writing.</p>
<p> In the end, I decided to go with AMD modules as I had some experience with <a href="http://requirejs.org/">RequireJS</a>.</p>
<p> Now, when I try to compile again it works as expected! One big JavaScript file ready to go.</p>
<p> ...sort of.</p>
<h2>Using My Compiled TypeScript</h2>
<p>Somewhere along the line, I assumed that whatever JavaScript file I compiled would only need me to add a <code>&#x3C;script></code> tag reference to point to it like any other JavaScript file. </p>
<p>This was my second mistake, albeit a pretty silly one.</p>
<p>AMD modules have always needed RequireJS to load properly. That's the purpose for RequireJS. Maybe I had assumed the TypeScript compiler would embed this library or something, but whatever my reasoning it was wrong. I needed to include a <code>data-main</code> file, as you do with every RequireJS example.</p>
<p>I added this to my HTML file, along with the RequireJS library in my project:</p>
<pre><code class="language-html">&#x3C;script data-main="main" type="text/javascript" src="lib/require.js">&#x3C;/script>
</code></pre>
<p>Then, my <code>data-main</code> file goes something like this:</p>
<pre><code class="language-javascript">// main.js
  
requirejs.config({
    baseUrl: 'lib',
    paths: {
        'App':'../app'
    }
});

requirejs(['App'], function(MyApp) {
    console.log('starting application...');

    var app = new MyApp.App();
    app.start();
});
</code></pre>
<p>I'm not going to go into the details here, but my <code>paths</code> object in the <code>requirejs.config</code> is pointing <code>App</code> to our outputted file. We use this in our main function and point our compiled modules to the <code>MyApp</code> object. We then call the <code>start()</code> function on our exported class and we are off to the races. </p>
<p>When we run the application, we see the following in the JavaScript console.</p>
<p><img src="http://i.imgur.com/38ngK52.png" alt="What the console window should look like"></p>
<h2>Details on Compilation</h2>
<p>I skipped that part on purpose, because I don't use the TSC compiler directly. Rather, I use <a href="https://github.com/ivogabe/gulp-typescript"><code>gulp-typescript</code></a> with a <code>tsconfig</code> file to compile my TypeScript and create sourcemaps for them. All of this is detailed on the <a href="https://www.npmjs.com/package/gulp-typescript">package page</a>, but I'll include my gulp task to make sure you have all the details in one place. </p>
<p>You're welcome. ;)</p>
<pre><code class="language-javascript">var tsProject = ts.createProject('tsconfig.json');

gulp.task('build-ts', ()=> {
    let tsResult = tsProject.src()
                    .pipe(sourcemaps.init()) // using gulp-sourcemaps as prescribed by gulp-typescript
                    .pipe(ts(tsProject));
    
    return tsResult
            .js
            .pipe(sourcemaps.write('./'))
            .pipe(gulp.dest('./dist'))
            .pipe(connect.reload());  // I use gulp-connect to watch and reload the page as I develop
});
</code></pre>
<p>Oh, and here's my <code>tsconfig.json</code> file too.</p>
<pre><code class="language-javascript">{
    "compilerOptions": {
        "module": "amd",
        "rootDir": "./src/ts",
        "sourceRoot": "./src/ts",
        "outFile": "app.js",
        "target": "es5"
    },
    "exclude": [
        "node_modules",
        "dist"
    ]
}
</code></pre>
</div></article><footer><a href="/blog">Back to Post Listing</a></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"typescript-with-amd-and-gulp","htmlContent":"\u003cp\u003eI've been tinkering with TypeScript lately and was trying to setup my project to compile all of my modules into a single file, which would then be used in an HTML page. Maybe this is obvious to the more experienced TypeScript developer, but I had made a number of false assumptions while trying to get this to work.\u003c/p\u003e\n\u003cp\u003eThis post will walk you through what I did to setup my build and get it working in an HTML page.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eYou can follow along at home with the source code which I've put up on \u003ca href=\"https://github.com/davidwesst/ts-project-template\"\u003eGitHub\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eModular TypeScript\u003c/h2\u003e\n\u003cp\u003eMy project is starting out simple, with a single module and a couple of different \"Apps\" that will use the module. Module in TypeScript is extensively documented in the \u003ca href=\"\"\u003eTypeScript Handbook\u003c/a\u003e, so if you're not familiar with this I would suggest reading up on it as it's pretty awesome once you start using it.\u003c/p\u003e\n\u003cp\u003eIn any case, here's my code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// ModuleOne.ts\n\nexport class ModuleOne {\n    sayHello() {\n        console.log(\"Hello from Module1!\");\n    }\n\n    sayHelloTo(who: string) {\n        console.log(\"Hello \" + who.trim() + \". This is Module1\");\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// ModuleTwo.ts\n\nexport class ModuleOne {\n    sayHello() {\n        console.log(\"Hello from ModuleTwo!\");\n    }\n\n    sayHelloTo(who: string) {\n        console.log(\"Hello \" + who.trim() + \". This is ModuleTwo\");\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-typescript\"\u003e// App.ts\n\nimport * as Module1 from \"./modules/Module1\";\nimport * as Module2 from \"./modules/Module2\";\n\nexport class App {\n    start() {\n        let m1 = new Module1.ModuleOne();\n        let m2 = new Module2.ModuleTwo();\n        \n        m1.sayHelloTo(\"David Wesst\");\n        m2.sayHelloTo(\"David Wesst\");\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI have a single application that is using two modules. Plain and simple. Next up, I compile my code into a single file, then reference that in my HTML, and done like dinner.\u003c/p\u003e\n\u003cp\u003e...or so I thought.\u003c/p\u003e\n\u003ch2\u003eThe \u003ccode\u003e--outFile\u003c/code\u003e Parameter\u003c/h2\u003e\n\u003cp\u003e Reading through the doucmentation about TypeScript compilation, I found the \u003ccode\u003e--outFile\u003c/code\u003e or \u003ccode\u003e--out\u003c/code\u003e parameter in the \u003ca href=\"https://www.typescriptlang.org/docs/handbook/compiler-options.html\"\u003edocumentation\u003c/a\u003e. I immediately assumed that I was done, as I would simple choose my ES target, select the type of modules I would like, and presto. \u003c/p\u003e\n\u003cp\u003e That wasn't the case.\u003c/p\u003e\n\u003cp\u003e Being a person who likes modern JavaScript, I had originally opted to output ES6 compatible code complete with the new modules. \u003c/p\u003e\n\u003cp\u003e This is was my first mistake. \u003c/p\u003e\n\u003cp\u003e I found was that when I compiled, I would get a single output file but it would be completely blank. No error, but just an empty file. This is expected behaviour, as the \u003ccode\u003e--outFile\u003c/code\u003e option only supports \u003cem\u003ecommonjs\u003c/em\u003e and \u003cem\u003eamd\u003c/em\u003e. That meant no ES6 or even ES2015 modules for my project, which is probably for the best considering how few web browsers in the wild actually support ES6 modules as of this writing.\u003c/p\u003e\n\u003cp\u003e In the end, I decided to go with AMD modules as I had some experience with \u003ca href=\"http://requirejs.org/\"\u003eRequireJS\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e Now, when I try to compile again it works as expected! One big JavaScript file ready to go.\u003c/p\u003e\n\u003cp\u003e ...sort of.\u003c/p\u003e\n\u003ch2\u003eUsing My Compiled TypeScript\u003c/h2\u003e\n\u003cp\u003eSomewhere along the line, I assumed that whatever JavaScript file I compiled would only need me to add a \u003ccode\u003e\u0026#x3C;script\u003e\u003c/code\u003e tag reference to point to it like any other JavaScript file. \u003c/p\u003e\n\u003cp\u003eThis was my second mistake, albeit a pretty silly one.\u003c/p\u003e\n\u003cp\u003eAMD modules have always needed RequireJS to load properly. That's the purpose for RequireJS. Maybe I had assumed the TypeScript compiler would embed this library or something, but whatever my reasoning it was wrong. I needed to include a \u003ccode\u003edata-main\u003c/code\u003e file, as you do with every RequireJS example.\u003c/p\u003e\n\u003cp\u003eI added this to my HTML file, along with the RequireJS library in my project:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026#x3C;script data-main=\"main\" type=\"text/javascript\" src=\"lib/require.js\"\u003e\u0026#x3C;/script\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen, my \u003ccode\u003edata-main\u003c/code\u003e file goes something like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// main.js\n  \nrequirejs.config({\n    baseUrl: 'lib',\n    paths: {\n        'App':'../app'\n    }\n});\n\nrequirejs(['App'], function(MyApp) {\n    console.log('starting application...');\n\n    var app = new MyApp.App();\n    app.start();\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI'm not going to go into the details here, but my \u003ccode\u003epaths\u003c/code\u003e object in the \u003ccode\u003erequirejs.config\u003c/code\u003e is pointing \u003ccode\u003eApp\u003c/code\u003e to our outputted file. We use this in our main function and point our compiled modules to the \u003ccode\u003eMyApp\u003c/code\u003e object. We then call the \u003ccode\u003estart()\u003c/code\u003e function on our exported class and we are off to the races. \u003c/p\u003e\n\u003cp\u003eWhen we run the application, we see the following in the JavaScript console.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"http://i.imgur.com/38ngK52.png\" alt=\"What the console window should look like\"\u003e\u003c/p\u003e\n\u003ch2\u003eDetails on Compilation\u003c/h2\u003e\n\u003cp\u003eI skipped that part on purpose, because I don't use the TSC compiler directly. Rather, I use \u003ca href=\"https://github.com/ivogabe/gulp-typescript\"\u003e\u003ccode\u003egulp-typescript\u003c/code\u003e\u003c/a\u003e with a \u003ccode\u003etsconfig\u003c/code\u003e file to compile my TypeScript and create sourcemaps for them. All of this is detailed on the \u003ca href=\"https://www.npmjs.com/package/gulp-typescript\"\u003epackage page\u003c/a\u003e, but I'll include my gulp task to make sure you have all the details in one place. \u003c/p\u003e\n\u003cp\u003eYou're welcome. ;)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003evar tsProject = ts.createProject('tsconfig.json');\n\ngulp.task('build-ts', ()=\u003e {\n    let tsResult = tsProject.src()\n                    .pipe(sourcemaps.init()) // using gulp-sourcemaps as prescribed by gulp-typescript\n                    .pipe(ts(tsProject));\n    \n    return tsResult\n            .js\n            .pipe(sourcemaps.write('./'))\n            .pipe(gulp.dest('./dist'))\n            .pipe(connect.reload());  // I use gulp-connect to watch and reload the page as I develop\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOh, and here's my \u003ccode\u003etsconfig.json\u003c/code\u003e file too.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e{\n    \"compilerOptions\": {\n        \"module\": \"amd\",\n        \"rootDir\": \"./src/ts\",\n        \"sourceRoot\": \"./src/ts\",\n        \"outFile\": \"app.js\",\n        \"target\": \"es5\"\n    },\n    \"exclude\": [\n        \"node_modules\",\n        \"dist\"\n    ]\n}\n\u003c/code\u003e\u003c/pre\u003e\n","layout":"post","title":"How to Compile Typescript into a Single File with AMD Modules with Gulp","date":"Mon Sep 12 2016 03:25:01 GMT-0500 (Central Daylight Time)","tags":["typescript","javascript","amd","requirejs","gulp"],"excerpt":"The lessons I learned and the steps I took to compile TypeScript modules into a single file with AMD modules using Gulp, along with how I consumed those compiled modules in my HTML application.","authorId":"david_wesst","originalurl":"https://blog.davidwesst.com/2016/09/How-to-Compile-Typescript-into-a-Single-File-with-AMD-Modules/"}},"__N_SSG":true},"page":"/blog/[id]","query":{"id":"typescript-with-amd-and-gulp"},"buildId":"-9wn_hi6_-Q32OgH9YOcv","assetPrefix":"https://www.davidwesst.com","runtimeConfig":{},"nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="https://www.davidwesst.com/_next/static/runtime/polyfills-10c88b4b028d13fe33de.js"></script><script async="" data-next-page="/_app" src="https://www.davidwesst.com/_next/static/-9wn_hi6_-Q32OgH9YOcv/pages/_app.js"></script><script async="" data-next-page="/blog/[id]" src="https://www.davidwesst.com/_next/static/-9wn_hi6_-Q32OgH9YOcv/pages/blog/%5Bid%5D.js"></script><script src="https://www.davidwesst.com/_next/static/runtime/webpack-c212667a5f965e81e004.js" async=""></script><script src="https://www.davidwesst.com/_next/static/chunks/framework.e84fa698c7ee940652bd.js" async=""></script><script src="https://www.davidwesst.com/_next/static/chunks/commons.7c101d7f1672b68d7c1c.js" async=""></script><script src="https://www.davidwesst.com/_next/static/runtime/main-98aa3916935decc0cde3.js" async=""></script><script src="https://www.davidwesst.com/_next/static/-9wn_hi6_-Q32OgH9YOcv/_buildManifest.js" async=""></script><script src="https://www.davidwesst.com/_next/static/-9wn_hi6_-Q32OgH9YOcv/_ssgManifest.js" async=""></script></body></html>